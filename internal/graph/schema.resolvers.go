package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"bytes"
	"context"
	"encoding/csv"
	"fmt"
	"io"
	"strconv"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
	"github.com/shiftregister-vg/card-craft/internal/auth"
	"github.com/shiftregister-vg/card-craft/internal/cards"
	"github.com/shiftregister-vg/card-craft/internal/graph/generated"
	"github.com/shiftregister-vg/card-craft/internal/models"
	"github.com/shiftregister-vg/card-craft/internal/types"
	"github.com/shiftregister-vg/card-craft/internal/utils"
)

// ID is the resolver for the id field.
func (r *cardResolver) ID(ctx context.Context, obj *models.Card) (string, error) {
	return obj.ID.String(), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *cardResolver) CreatedAt(ctx context.Context, obj *models.Card) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *cardResolver) UpdatedAt(ctx context.Context, obj *models.Card) (string, error) {
	return obj.UpdatedAt.Format(time.RFC3339), nil
}

// Cards is the resolver for the cards field.
func (r *cardSearchResultResolver) Cards(ctx context.Context, obj *types.CardSearchResult) ([]*models.Card, error) {
	result := make([]*models.Card, len(obj.Cards))
	for i, card := range obj.Cards {
		result[i] = r.cardStore.ToModel(card)
	}
	return result, nil
}

// ID is the resolver for the id field.
func (r *collectionResolver) ID(ctx context.Context, obj *models.Collection) (string, error) {
	return obj.ID.String(), nil
}

// UserID is the resolver for the userId field.
func (r *collectionResolver) UserID(ctx context.Context, obj *models.Collection) (string, error) {
	return obj.UserID.String(), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *collectionResolver) CreatedAt(ctx context.Context, obj *models.Collection) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *collectionResolver) UpdatedAt(ctx context.Context, obj *models.Collection) (string, error) {
	return obj.UpdatedAt.Format(time.RFC3339), nil
}

// ID is the resolver for the id field.
func (r *collectionCardResolver) ID(ctx context.Context, obj *models.CollectionCard) (string, error) {
	return obj.ID.String(), nil
}

// CollectionID is the resolver for the collectionId field.
func (r *collectionCardResolver) CollectionID(ctx context.Context, obj *models.CollectionCard) (string, error) {
	return obj.CollectionID.String(), nil
}

// CardID is the resolver for the cardId field.
func (r *collectionCardResolver) CardID(ctx context.Context, obj *models.CollectionCard) (string, error) {
	return obj.CardID.String(), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *collectionCardResolver) CreatedAt(ctx context.Context, obj *models.CollectionCard) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *collectionCardResolver) UpdatedAt(ctx context.Context, obj *models.CollectionCard) (string, error) {
	return obj.UpdatedAt.Format(time.RFC3339), nil
}

// ID is the resolver for the id field.
func (r *deckResolver) ID(ctx context.Context, obj *models.Deck) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// UserID is the resolver for the userId field.
func (r *deckResolver) UserID(ctx context.Context, obj *models.Deck) (string, error) {
	panic(fmt.Errorf("not implemented: UserID - userId"))
}

// CreatedAt is the resolver for the createdAt field.
func (r *deckResolver) CreatedAt(ctx context.Context, obj *models.Deck) (string, error) {
	panic(fmt.Errorf("not implemented: CreatedAt - createdAt"))
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *deckResolver) UpdatedAt(ctx context.Context, obj *models.Deck) (string, error) {
	panic(fmt.Errorf("not implemented: UpdatedAt - updatedAt"))
}

// Cards is the resolver for the cards field.
func (r *deckResolver) Cards(ctx context.Context, obj *models.Deck) ([]*models.DeckCard, error) {
	panic(fmt.Errorf("not implemented: Cards - cards"))
}

// ID is the resolver for the id field.
func (r *deckCardResolver) ID(ctx context.Context, obj *models.DeckCard) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// DeckID is the resolver for the deckId field.
func (r *deckCardResolver) DeckID(ctx context.Context, obj *models.DeckCard) (string, error) {
	panic(fmt.Errorf("not implemented: DeckID - deckId"))
}

// CardID is the resolver for the cardId field.
func (r *deckCardResolver) CardID(ctx context.Context, obj *models.DeckCard) (string, error) {
	panic(fmt.Errorf("not implemented: CardID - cardId"))
}

// CreatedAt is the resolver for the createdAt field.
func (r *deckCardResolver) CreatedAt(ctx context.Context, obj *models.DeckCard) (string, error) {
	panic(fmt.Errorf("not implemented: CreatedAt - createdAt"))
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *deckCardResolver) UpdatedAt(ctx context.Context, obj *models.DeckCard) (string, error) {
	panic(fmt.Errorf("not implemented: UpdatedAt - updatedAt"))
}

// Card is the resolver for the card field.
func (r *deckCardResolver) Card(ctx context.Context, obj *models.DeckCard) (*models.Card, error) {
	panic(fmt.Errorf("not implemented: Card - card"))
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, email string, password string) (*models.AuthPayload, error) {
	return r.authService.Register(username, email, password)
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, identifier string, password string) (*models.AuthPayload, error) {
	fmt.Printf("GraphQL Login resolver called with identifier: %s\n", identifier)

	payload, err := r.authService.Login(identifier, password)
	if err != nil {
		fmt.Printf("Login resolver error: %v\n", err)
		if err == auth.ErrInvalidCredentials {
			return nil, fmt.Errorf("invalid credentials")
		}
		return nil, err
	}

	fmt.Printf("Login resolver successful for identifier: %s\n", identifier)
	return payload, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context) (*models.AuthPayload, error) {
	return r.authService.RefreshToken(ctx)
}

// CreateCard is the resolver for the createCard field.
func (r *mutationResolver) CreateCard(ctx context.Context, input models.CardInput) (*models.Card, error) {
	panic(fmt.Errorf("not implemented: CreateCard - createCard"))
}

// UpdateCard is the resolver for the updateCard field.
func (r *mutationResolver) UpdateCard(ctx context.Context, id string, input models.CardInput) (*models.Card, error) {
	panic(fmt.Errorf("not implemented: UpdateCard - updateCard"))
}

// DeleteCard is the resolver for the deleteCard field.
func (r *mutationResolver) DeleteCard(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteCard - deleteCard"))
}

// CreateDeck is the resolver for the createDeck field.
func (r *mutationResolver) CreateDeck(ctx context.Context, input types.DeckInput) (*models.Deck, error) {
	panic(fmt.Errorf("not implemented: CreateDeck - createDeck"))
}

// UpdateDeck is the resolver for the updateDeck field.
func (r *mutationResolver) UpdateDeck(ctx context.Context, id string, input types.DeckInput) (*models.Deck, error) {
	panic(fmt.Errorf("not implemented: UpdateDeck - updateDeck"))
}

// DeleteDeck is the resolver for the deleteDeck field.
func (r *mutationResolver) DeleteDeck(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteDeck - deleteDeck"))
}

// AddCardToDeck is the resolver for the addCardToDeck field.
func (r *mutationResolver) AddCardToDeck(ctx context.Context, deckID string, input types.DeckCardInput) (*models.DeckCard, error) {
	panic(fmt.Errorf("not implemented: AddCardToDeck - addCardToDeck"))
}

// UpdateDeckCard is the resolver for the updateDeckCard field.
func (r *mutationResolver) UpdateDeckCard(ctx context.Context, id string, quantity int) (*models.DeckCard, error) {
	panic(fmt.Errorf("not implemented: UpdateDeckCard - updateDeckCard"))
}

// RemoveCardFromDeck is the resolver for the removeCardFromDeck field.
func (r *mutationResolver) RemoveCardFromDeck(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: RemoveCardFromDeck - removeCardFromDeck"))
}

// ImportCollection is the resolver for the importCollection field.
func (r *mutationResolver) ImportCollection(ctx context.Context, input models.ImportSource, file graphql.Upload) (*models.ImportResult, error) {
	panic(fmt.Errorf("not implemented: ImportCollection - importCollection"))
}

// CreateCollection is the resolver for the createCollection field.
func (r *mutationResolver) CreateCollection(ctx context.Context, input models.CollectionInput) (*models.Collection, error) {
	user := auth.GetUserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	collection := &models.Collection{
		ID:          uuid.New(),
		UserID:      user.ID,
		Name:        input.Name,
		Description: utils.DerefString(input.Description),
		Game:        input.Game,
	}

	if err := r.collectionStore.Create(collection); err != nil {
		return nil, err
	}

	return collection, nil
}

// UpdateCollection is the resolver for the updateCollection field.
func (r *mutationResolver) UpdateCollection(ctx context.Context, id string, input models.CollectionInput) (*models.Collection, error) {
	user := auth.GetUserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	uuid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	collection, err := r.collectionStore.FindByID(uuid)
	if err != nil {
		return nil, err
	}

	if collection == nil {
		return nil, fmt.Errorf("collection not found")
	}

	if collection.UserID != user.ID {
		return nil, fmt.Errorf("unauthorized")
	}

	collection.Name = input.Name
	collection.Description = utils.DerefString(input.Description)
	collection.Game = input.Game

	if err := r.collectionStore.Update(collection); err != nil {
		return nil, err
	}

	return collection, nil
}

// DeleteCollection is the resolver for the deleteCollection field.
func (r *mutationResolver) DeleteCollection(ctx context.Context, id string) (bool, error) {
	user := auth.GetUserFromContext(ctx)
	if user == nil {
		return false, fmt.Errorf("not authenticated")
	}

	uuid, err := uuid.Parse(id)
	if err != nil {
		return false, err
	}

	if err := r.collectionStore.Delete(uuid, user.ID); err != nil {
		return false, err
	}

	return true, nil
}

// AddCardToCollection is the resolver for the addCardToCollection field.
func (r *mutationResolver) AddCardToCollection(ctx context.Context, collectionID string, input models.CollectionCardInput) (*models.CollectionCard, error) {
	user := auth.GetUserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	collectionUUID, err := uuid.Parse(collectionID)
	if err != nil {
		return nil, err
	}

	cardUUID, err := uuid.Parse(input.CardID)
	if err != nil {
		return nil, err
	}

	collection, err := r.collectionStore.FindByID(collectionUUID)
	if err != nil {
		return nil, err
	}

	if collection.UserID != user.ID {
		return nil, fmt.Errorf("not authorized")
	}

	card, err := r.cardStore.FindByID(cardUUID)
	if err != nil {
		return nil, err
	}

	if card == nil {
		return nil, fmt.Errorf("card not found")
	}

	collectionCard := &models.CollectionCard{
		ID:           uuid.New(),
		CollectionID: collectionUUID,
		CardID:       cardUUID,
		Card:         r.cardStore.ToModel(card),
		Quantity:     input.Quantity,
		IsFoil:       utils.DerefBool(input.IsFoil),
		Condition:    utils.DerefString(input.Condition),
		Notes:        utils.DerefString(input.Notes),
	}

	if err := r.collectionStore.AddCard(collectionCard); err != nil {
		return nil, err
	}

	return collectionCard, nil
}

// UpdateCollectionCard is the resolver for the updateCollectionCard field.
func (r *mutationResolver) UpdateCollectionCard(ctx context.Context, id string, input models.CollectionCardInput) (*models.CollectionCard, error) {
	user := auth.GetUserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	collectionCardUUID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	collectionCard, err := r.collectionStore.GetCard(collectionCardUUID)
	if err != nil {
		return nil, err
	}

	collection, err := r.collectionStore.FindByID(collectionCard.CollectionID)
	if err != nil {
		return nil, err
	}

	if collection.UserID != user.ID {
		return nil, fmt.Errorf("not authorized")
	}

	collectionCard.Quantity = input.Quantity
	collectionCard.IsFoil = utils.DerefBool(input.IsFoil)
	collectionCard.Condition = utils.DerefString(input.Condition)
	collectionCard.Notes = utils.DerefString(input.Notes)

	if err := r.collectionStore.UpdateCard(collectionCard); err != nil {
		return nil, err
	}

	return collectionCard, nil
}

// RemoveCardFromCollection is the resolver for the removeCardFromCollection field.
func (r *mutationResolver) RemoveCardFromCollection(ctx context.Context, id string) (bool, error) {
	user := auth.GetUserFromContext(ctx)
	if user == nil {
		return false, fmt.Errorf("not authenticated")
	}

	cardUUID, err := uuid.Parse(id)
	if err != nil {
		return false, err
	}

	card, err := r.collectionStore.GetCard(cardUUID)
	if err != nil {
		return false, err
	}

	if card == nil {
		return false, fmt.Errorf("collection card not found")
	}

	collection, err := r.collectionStore.FindByID(card.CollectionID)
	if err != nil {
		return false, err
	}

	if collection == nil {
		return false, fmt.Errorf("collection not found")
	}

	if collection.UserID != user.ID {
		return false, fmt.Errorf("unauthorized")
	}

	if err := r.collectionStore.RemoveCard(cardUUID); err != nil {
		return false, err
	}

	return true, nil
}

// ImportCards is the resolver for the importCards field.
func (r *mutationResolver) ImportCards(ctx context.Context, game string) (bool, error) {
	var importer cards.CardImporter
	switch game {
	case "pokemon":
		importer = cards.NewPokemonImporter(r.cardStore, r.pokemonStore)
	default:
		return false, fmt.Errorf("unsupported game: %s", game)
	}

	if err := importer.Import(ctx, r.cardStore); err != nil {
		return false, err
	}

	return true, nil
}

// BulkImportCardsToCollection is the resolver for the bulkImportCardsToCollection field.
func (r *mutationResolver) BulkImportCardsToCollection(ctx context.Context, collectionID string, file graphql.Upload) (*models.BulkImportResult, error) {
	user := auth.GetUserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	collectionUUID, err := uuid.Parse(collectionID)
	if err != nil {
		return nil, err
	}

	collection, err := r.collectionStore.FindByID(collectionUUID)
	if err != nil {
		return nil, err
	}

	if collection.UserID != user.ID {
		return nil, fmt.Errorf("not authorized")
	}

	// Read the CSV file
	content, err := io.ReadAll(file.File)
	if err != nil {
		return nil, fmt.Errorf("error reading file: %w", err)
	}

	// Parse CSV
	reader := csv.NewReader(bytes.NewReader(content))
	headers, err := reader.Read()
	if err != nil {
		return nil, fmt.Errorf("error reading CSV headers: %w", err)
	}

	// Map column indices
	columnMap := make(map[string]int)
	for i, header := range headers {
		columnMap[strings.TrimSpace(header)] = i
	}

	// Required columns for TCG Collector format
	requiredColumns := []string{"Expansion", "Card number", "Card name", "Quantity"}
	for _, col := range requiredColumns {
		if _, ok := columnMap[col]; !ok {
			return nil, fmt.Errorf("missing required column: %s", col)
		}
	}

	var importedCount int
	var errors []*models.ImportError

	// Process each row
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("error reading CSV row: %w", err)
		}

		// Extract values
		setCode := strings.ToLower(strings.TrimSpace(record[columnMap["Expansion"]]))
		number := strings.TrimSpace(record[columnMap["Card number"]])
		// Extract just the number part if it's in "x/y" format
		if strings.Contains(number, "/") {
			number = strings.Split(number, "/")[0]
		}
		quantity, err := strconv.Atoi(strings.TrimSpace(record[columnMap["Quantity"]]))
		if err != nil {
			errors = append(errors, &models.ImportError{
				CardID:  fmt.Sprintf("%s/%s", setCode, number),
				Message: "invalid quantity",
			})
			continue
		}

		// Optional fields
		condition := "NM"
		if idx, ok := columnMap["Card condition"]; ok {
			condition = strings.TrimSpace(record[idx])
		}

		isFoil := false
		if idx, ok := columnMap["Card variant"]; ok {
			variant := strings.ToLower(strings.TrimSpace(record[idx]))
			isFoil = strings.Contains(variant, "holo") || strings.Contains(variant, "reverse")
		}

		notes := ""
		if idx, ok := columnMap["Note"]; ok {
			notes = strings.TrimSpace(record[idx])
		}

		// Find the card - ensure game is pokemon and all comparisons are case-insensitive
		card, err := r.cardStore.FindByGameAndNumber("pokemon", setCode, number)
		if err != nil {
			errors = append(errors, &models.ImportError{
				CardID:  fmt.Sprintf("%s/%s", setCode, number),
				Message: fmt.Sprintf("error finding card: %v", err),
			})
			continue
		}

		if card == nil {
			errors = append(errors, &models.ImportError{
				CardID:  fmt.Sprintf("%s/%s", setCode, number),
				Message: "card not found - please ensure the set name and card number match exactly",
			})
			continue
		}

		// Create collection card
		collectionCard := &models.CollectionCard{
			ID:           uuid.New(),
			CollectionID: collectionUUID,
			CardID:       card.ID,
			Card:         r.cardStore.ToModel(card),
			Quantity:     quantity,
			IsFoil:       isFoil,
			Condition:    condition,
			Notes:        notes,
		}

		if err := r.collectionStore.AddCard(collectionCard); err != nil {
			errors = append(errors, &models.ImportError{
				CardID:  fmt.Sprintf("%s/%s", setCode, number),
				Message: "error adding card to collection",
			})
			continue
		}

		importedCount++
	}

	return &models.BulkImportResult{
		Success:       true,
		ImportedCount: importedCount,
		Errors:        errors,
	}, nil
}

// Card is the resolver for the card field.
func (r *queryResolver) Card(ctx context.Context, id string) (*models.Card, error) {
	panic(fmt.Errorf("not implemented: Card - card"))
}

// CardsByGame is the resolver for the cardsByGame field.
func (r *queryResolver) CardsByGame(ctx context.Context, game string, first *int, after *string) (*models.CardConnection, error) {
	limit := 100 // Default to 100 cards per page
	if first != nil {
		limit = *first
	}

	afterCursor := ""
	if after != nil {
		afterCursor = *after
	}

	typeCards, nextCursor, err := r.cardStore.FindByGame(game, limit, afterCursor)
	if err != nil {
		return nil, err
	}

	edges := make([]*models.CardEdge, len(typeCards))
	for i, card := range typeCards {
		modelCard := r.cardStore.ToModel(card)
		edges[i] = &models.CardEdge{
			Node:   modelCard,
			Cursor: fmt.Sprintf("%s:%s", card.SetCode, card.Number),
		}
	}

	return &models.CardConnection{
		Edges: edges,
		PageInfo: &models.PageInfo{
			HasNextPage: nextCursor != "",
			EndCursor:   &nextCursor,
		},
	}, nil
}

// CardsBySet is the resolver for the cardsBySet field.
func (r *queryResolver) CardsBySet(ctx context.Context, game string, setCode string) ([]*models.Card, error) {
	panic(fmt.Errorf("not implemented: CardsBySet - cardsBySet"))
}

// SearchCards is the resolver for the searchCards field.
func (r *queryResolver) SearchCards(ctx context.Context, game *string, setCode *string, rarity *string, name *string, page *int, pageSize *int, sortBy *string, sortOrder *string) (*types.CardSearchResult, error) {
	if game == nil {
		return nil, fmt.Errorf("game is required")
	}

	opts := types.SearchOptions{
		Game:      *game,
		SetCode:   utils.DerefString(setCode),
		Rarity:    utils.DerefString(rarity),
		Name:      utils.DerefString(name),
		Page:      utils.DerefInt(page),
		PageSize:  utils.DerefInt(pageSize),
		SortBy:    utils.DerefString(sortBy),
		SortOrder: utils.DerefString(sortOrder),
	}

	return r.searchService.Search(opts)
}

// CardFilters is the resolver for the cardFilters field.
func (r *queryResolver) CardFilters(ctx context.Context, game string) (*types.CardFilters, error) {
	panic(fmt.Errorf("not implemented: CardFilters - cardFilters"))
}

// Deck is the resolver for the deck field.
func (r *queryResolver) Deck(ctx context.Context, id string) (*models.Deck, error) {
	panic(fmt.Errorf("not implemented: Deck - deck"))
}

// MyDecks is the resolver for the myDecks field.
func (r *queryResolver) MyDecks(ctx context.Context) ([]*models.Deck, error) {
	panic(fmt.Errorf("not implemented: MyDecks - myDecks"))
}

// DeckCards is the resolver for the deckCards field.
func (r *queryResolver) DeckCards(ctx context.Context, deckID string) ([]*models.DeckCard, error) {
	panic(fmt.Errorf("not implemented: DeckCards - deckCards"))
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	user := auth.GetUserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	return user, nil
}

// Collection is the resolver for the collection field.
func (r *queryResolver) Collection(ctx context.Context, id string) (*models.Collection, error) {
	uuid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	return r.collectionStore.FindByID(uuid)
}

// MyCollections is the resolver for the myCollections field.
func (r *queryResolver) MyCollections(ctx context.Context) ([]*models.Collection, error) {
	user := auth.GetUserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	return r.collectionStore.FindByUserID(user.ID)
}

// CollectionCards is the resolver for the collectionCards field.
func (r *queryResolver) CollectionCards(ctx context.Context, collectionID string) ([]*models.CollectionCard, error) {
	uuid, err := uuid.Parse(collectionID)
	if err != nil {
		return nil, err
	}
	return r.collectionStore.GetCards(uuid)
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *models.User) (string, error) {
	return obj.ID.String(), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *userResolver) CreatedAt(ctx context.Context, obj *models.User) (string, error) {
	panic(fmt.Errorf("not implemented: CreatedAt - createdAt"))
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *userResolver) UpdatedAt(ctx context.Context, obj *models.User) (string, error) {
	panic(fmt.Errorf("not implemented: UpdatedAt - updatedAt"))
}

// Card returns generated.CardResolver implementation.
func (r *Resolver) Card() generated.CardResolver { return &cardResolver{r} }

// CardSearchResult returns generated.CardSearchResultResolver implementation.
func (r *Resolver) CardSearchResult() generated.CardSearchResultResolver {
	return &cardSearchResultResolver{r}
}

// Collection returns generated.CollectionResolver implementation.
func (r *Resolver) Collection() generated.CollectionResolver { return &collectionResolver{r} }

// CollectionCard returns generated.CollectionCardResolver implementation.
func (r *Resolver) CollectionCard() generated.CollectionCardResolver {
	return &collectionCardResolver{r}
}

// Deck returns generated.DeckResolver implementation.
func (r *Resolver) Deck() generated.DeckResolver { return &deckResolver{r} }

// DeckCard returns generated.DeckCardResolver implementation.
func (r *Resolver) DeckCard() generated.DeckCardResolver { return &deckCardResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type cardResolver struct{ *Resolver }
type cardSearchResultResolver struct{ *Resolver }
type collectionResolver struct{ *Resolver }
type collectionCardResolver struct{ *Resolver }
type deckResolver struct{ *Resolver }
type deckCardResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
